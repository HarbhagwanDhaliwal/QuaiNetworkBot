"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCoinSelector = void 0;
const utxo_js_1 = require("./utxo.js");
class AbstractCoinSelector {
    availableUTXOs;
    totalInputValue = BigInt(0);
    spendOutputs = [];
    changeOutputs = [];
    selectedUTXOs = [];
    target = null;
    /**
     * Constructs a new AbstractCoinSelector instance with an empty UTXO array.
     *
     * @param {UTXO[]} [availableUXTOs=[]] - The initial available UTXOs. Default is `[]`
     */
    constructor(availableUTXOs = []) {
        this.availableUTXOs = availableUTXOs.map((utxo) => {
            this._validateUTXO(utxo);
            return utxo;
        });
        this.spendOutputs = [];
        this.changeOutputs = [];
    }
    /**
     * Validates the provided UTXO instance. In order to be valid for coin selection, the UTXO must have a valid address
     * and denomination.
     *
     * @param {UTXO} utxo - The UTXO to validate.
     * @throws {Error} If the UTXO is invalid.
     * @protected
     */
    _validateUTXO(utxo) {
        if (utxo.address == null) {
            throw new Error('UTXO address is required');
        }
        if (utxo.denomination == null) {
            throw new Error('UTXO denomination is required');
        }
        if (utxo.txhash == null) {
            throw new Error('UTXO txhash is required');
        }
        if (utxo.index == null) {
            throw new Error('UTXO index is required');
        }
    }
    /**
     * Validates the available UTXOs.
     *
     * @throws Will throw an error if there are no available UTXOs.
     */
    validateUTXOs() {
        if (this.availableUTXOs.length === 0) {
            throw new Error('No UTXOs available');
        }
    }
    /**
     * Sorts UTXOs by their denomination.
     *
     * @param {UTXO[]} utxos - The UTXOs to sort.
     * @param {'asc' | 'desc'} direction - The direction to sort ('asc' for ascending, 'desc' for descending).
     * @returns {UTXO[]} The sorted UTXOs.
     */
    sortUTXOsByDenomination(utxos, direction) {
        if (direction === 'asc') {
            return [...utxos].sort((a, b) => {
                const diff = BigInt(a.denomination !== null ? utxo_js_1.denominations[a.denomination] : 0) -
                    BigInt(b.denomination !== null ? utxo_js_1.denominations[b.denomination] : 0);
                return diff > BigInt(0) ? 1 : diff < BigInt(0) ? -1 : 0;
            });
        }
        return [...utxos].sort((a, b) => {
            const diff = BigInt(b.denomination !== null ? utxo_js_1.denominations[b.denomination] : 0) -
                BigInt(a.denomination !== null ? utxo_js_1.denominations[a.denomination] : 0);
            return diff > BigInt(0) ? 1 : diff < BigInt(0) ? -1 : 0;
        });
    }
}
exports.AbstractCoinSelector = AbstractCoinSelector;
//# sourceMappingURL=abstract-coinselector.js.map